两种思路
### 正常搜索
判断当前岛屿是否被包围，是则结果加1
具体算法
1. 如果当前节点是岛屿，那么它可能是隔离，也可能不是被水域包围
2. 用一个全局变量标示隔离情况，用DFS/BFS,从当前点上下左右搜索，如果有遇到边界情况，将其标记为非隔离

代码
```javascript
var closedIsland1 = function (grid) {
  let maybe = 1;
  let res = 0;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      if (grid[i][j] === 0) {
        maybe = 1;
        dfs(i, j);
        res += maybe;
      }
    }
  }
  console.log({ res });

  return res;

  function dfs(i, j) {
    // 顺时针4个方向
    let dirs = [
      [-1, 0],
      [0, 1],
      [1, 0],
      [0, -1],
    ];
    if (
      i === 0 ||
      j === 0 ||
      i === grid.length - 1 ||
      j === grid[0].length - 1
    ) {
      maybe = 0;
    }

    grid[i][j] = 1;

    for (let [dx, dy] of dirs) {
      let [x, y] = [dx + i, dy + j];
      if (isValid(x, y)) {
        dfs(x, y);
      }
    }
  }

  function isValid(x, y) {
    return (
      x >= 0 &&
      y >= 0 &&
      x < grid.length &&
      y < grid[0].length &&
      grid[x][y] === 0
    );
  }
};
```


### 着色标记
从边界节点搜索，将和边界岛屿相连的岛屿都标记，计算标记完后的隔离岛屿数量
```javascript
function closedIsland(grid) {
  // 标记左右两个边界
  for (let i = 0; i < grid.length; i++) {
    dfs(i, 0);
    dfs(i, grid[0].length - 1);
  }
  // 标记上下边界
  for (let i = 0; i < grid[0].length; i++) {
    dfs(0, i);
    dfs(grid.length - 1, i);
  }

  let res = 0;
  // 计算剩下的岛屿数
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      if (grid[i][j] === 0) {
        dfs(i, j);
        res++;
      }
    }
  }
  return res;

  function dfs(i, j) {
    if (!isValid(i, j)) {
      return;
    }
    grid[i][j] = 1;
    dfs(i - 1, j);
    dfs(i + 1, j);
    dfs(i, j - 1);
    dfs(i, j + 1);
  }

  function isValid(i, j) {
    return (
      i >= 0 &&
      j >= 0 &&
      i < grid.length &&
      j < grid[0].length &&
      grid[i][j] === 0
    );
  }
}
```

上述两个解法每个节点都会被遍历一次，所以时间复杂度是O(n), n是节点数量，空间复杂度也是O(n), n是节点数量