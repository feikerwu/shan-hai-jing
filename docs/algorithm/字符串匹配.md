# 字符串匹配

字符串搜索算法（String searching algorithms）又称字符串比对算法（string matching algorithms）是一种搜索算法，是字符串算法中的一类，用以试图在一长字符串或文章中，找出其是否包含某一个或多个字符串，以及其位置。

用数学语言描述如下:

假设文本串 T 是一个长度为 n 的数组 $T[1..n]$, P 是长度为 m 的数组 $P[1..m]$, 其中 T 被称为文本串，P 被称为模式串。如果有 $0 <= s < m-n$, 使得 T[s, s + 1, .., s + m] 等于 P[1..m], 则称 P 在 T 中出现且位移为 s

字符串匹配问题就是找到模式串在文本串中的位移 s

<!-- 字符串匹配的概念 -->

## 暴力

遍历文本串，对遍历到的每个位置 i, 判断 $T[i..i+m]$ 是否和模式串$P[1..m]$相等
伪代码

```
n = length[T]
m = length[P]

for s = 0 to n - m
  do if T[s...s+m] == P[1...m]
    find s
```

时间复杂度 $O((n - m + 1) * n)$, 空间复杂度$O(1)$

这种暴力算法效率并不高，因为对于 s 的每个值，我们获得文本串和模式串的信息在考虑 s 的其它值时被丢弃了。比如 t = 'aaaabbbb', p = 'aabb'
当 s = 1 时，我们判断了 t[1] == p[1], t[2] == p[2], t[3] != p[3], s 递增判断 s=2 的情况，注意到在判断 s = 1 的时候，我们已经知道了 t[2] == p[2], 但是这个时候我们还要计算 t[2] 和 p[2]的比对情况，导致了计算重复。如果我们充分利用之前计算过的匹配信息，算法效率会有什么样的提升呢，接下来介绍另外几种算法。

## RK

RK 算法主要思想主要是对 T 中每个长度为 m 的子字符串 T[s..s+m] 做哈希，生成哈希值 h1, 对 P 做哈希，生成哈希值 h2, 比对 h1 和 h2，如果两个哈希值(不考虑冲突)相等，则判断 P 在 T 中出现，且位移为 s

伪代码

```
hp = hash(P[0..m])
for s = 0 to n - m
  hs = hash(T[s..s+m])
  if hp == hs
  then print 'find s'
```

[示意图](https://excalidraw.com/?authuser=feikerwu@gmail.com#json=4830663878377472,Kjv3FXAgRe0QtD5Jex2OJw)

## KMP
