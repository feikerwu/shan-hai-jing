> 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
> 示例 1:
> 输入:
> A: [1,2,3,2,1]
> B: [3,2,1,4,7]
> 输出: 3
> 解释:
> 长度最长的公共子数组是 [3, 2, 1]。
> 说明:
> 1 <= len(A), len(B) <= 1000
> 0 <= A[i], B[i] < 100

## 动态规划

定义二维状态 `dp[i][j]` 为数组 A[0..i], B[0..j]的最长相同后缀长度
状态转移方程为
$ dp[i][j] = d[i-1][j-1] + 1 (when A[i] == B[j]) $
时间复杂度为 $O(m * n)$, 空间复杂度 $O(m * n)$

```js
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var findLength = function (A, B) {
  A = [-1, ...A];
  B = [-1, ...B];
  let res = 0;
  const dp = Array.from(A).map(() => Array.from(B).fill(0));
  for (let i = 1; i < A.length; i++) {
    for (let j = 1; j < B.length; j++) {
      if (A[i] === B[j]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      }
      res = Math.max(res, dp[i][j]);
    }
  }
  return res;
};
```

## 滑动窗口

移动 A，B，使用滑动窗口判断每次 A 和 B 的最长重复子序列

```js
var findLength = function (A, B) {
  let res = 0;
  for (let i = 0; i < A.length; i++) {
    res = Math.max(res, getSubMaxLength(A.slice(i), B));
  }
  for (let j = 0; j < B.length; j++) {
    res = Math.max(res, getSubMaxLength(A, B.slice(j)));
  }
  return res;

  function getSubMaxLength(subA, subB) {
    let count = 0,
      term = 0;
    for (let i = 0; i < Math.min(subA.length, subB.length); i++) {
      if (subA[i] === subB[i]) {
        term++;
        count = Math.max(count, term);
      } else {
        term = 0;
      }
    }
    return count;
  }
};
```
